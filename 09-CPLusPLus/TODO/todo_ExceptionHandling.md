# Modern C++ 中错误处理的最佳实践

## 引言

在 Modern C++ 中，大多数情况下，**异常**都是处理程序错误的首选方式，这包括程序的逻辑错误和运行时错误。异常为包含错误的代码提供了一种标准且明确的手段，使错误信息能够在调用栈中向上层传递。

## 异常处理

程序错误通常分为两类：
- 编码引入的逻辑错误，如 "index out of range"。
- 运行时错误，如 "network service unavailable"。
  
在 C 风格代码或者 COM 中，错误的返回主要通过以下方式实现：
- 返回错误码或者特定函数的状态码。例如在 COM 中，通过返回 `HRESULT`，从而将错误信息返回给调用代码。
- 设置一个全局变量用于保存错误信息。例如 Win32 API 有 `GetLastError` 函数来获取调用栈中最新的错误信息。
 
以上两种情况，都是依赖于调用代码对错误进行处理。如果调用方没有处理错误代码，程序可能会在没有任何告警的情况下崩溃，或者继续使用错误的数据产生错误的结果。

在 Modern C++ 中，使用异常处理通常是更为推荐的做法，这有以下几点原因：
- 异常强制保证了调用代码能够识别发生错误的条件并进行处理，未处理的异常会终止程序的运行。
- 异常发生时，代码可以跳转到能够处理异常的部分，异常可以在栈中传递，实现程序中异常产生部分和异常处理部分的分离。
- 异常的栈展开机制（stack-unwinding mechanism）会依照明确定义的规则，在异常抛出后销毁所有作用域内的对象。

以下示例包含了抛出和捕获 C++ 异常的语法：

```cpp
#include <stdexcept>
#include <limits>
#include <iostream>

using namespace std;

void MyFunc(int c)
{
    if (c > numeric_limits<char> ::max())
        throw invalid_argument("MyFunc argument too large.");
    //...
}

int main()
{
    try
    {
        MyFunc(256); //cause an exception to throw
    }

    catch (invalid_argument& e)
    {
        cerr << e.what() << endl;
        return -1;
    }
    //...
    return 0;
}
```

C++ 中的异常和 C# 以及 Java 中的很像。在 `try` 块中，如果异常被抛出，他会被首个满足异常类型的 `catch` 块捕获，即，异常从 throw 表达式跳转到了 catch 表达式。如果没有满足条件的 catch 块，`std::terminate` 会被触发并且程序会退出。

在 C++ 中，任何类型都可以被抛出，然而，建议只抛出继承于 `std::exception` 类型的异常。上述示例中，异常类型 `invalid_argument` 是在头文件 `<stdexcept>` 包含的标准库中定义的。 

异常被抛出后，C++ 不提供(也不需要) `finally` 块来保证资源的释放。可以使用智能指针来管理资源的释放。

## 异常处理的基本原则

如何设计完善的异常处理程序在任何编程语言中都是个挑战。尽管异常为代码中的错误处理提供了不少支持，不代表异常处理就是万能的，我们仍然需要合理的设计异常处理程序：

- 使用断言来诊断不该发生的错误，而使用异常来处理可能发生的错误，如 `public` 函数的参数检验。
- 总是使用异常来检验 `public` 函数的参数。因为即使你的函数本身没有问题，你无法完全保证在任何参数下，它都一定正确。
- 当需要将包含错误的代码和处理错误的代码分离时，请使用异常。
- 在对性能要求较为严格的地方，权衡是否应该使用异常。
- 对于每个可能抛出或者传递异常的函数，满足 *the strong guarantee*, *the basic guarantee*, 或 *the nothrow (noexcept) guarantee* 中的一个。
- 抛出异常的时候使用值类型，捕获异常的时候使用引用类型。
- 不要捕获不能处理的异常。
- 不要使用 `throw()`，应该使用 `noexcept`。
- 尽可能使用标准库提供的异常类型，确实需要自定义异常类型，也应该继承标准的异常类型。
- 不要在析构函数或者内存释放函数中抛出异常。

## 异常处理和性能开销

如果没有异常抛出，异常机制会带来轻微的性能开销。如果有异常抛出，性能开销基本和函数调用差不多。

**大多数情况下，异常处理带来的性能和内存的损耗可以忽略不计。**

即使需要考虑性能的情况下，也应该知道，异常能够为程序提供更高的正确率，更好的维护性。

## 异常 vs 断言

**异常和断言是两种完全不同的用于检测程序运行时错误的机制。**

在开发过程中，使用断言来表示：只要你的代码是正确的，某些错误发生的条件一定不会成立。用异常来处理这种错误是没有意义的，因为它表明了代码中必然存在着需要修改的部分。断言不表示在某种错误条件成立的情况下，程序可以在运行时从错误中恢复。断言在声明处中止程序执行，从而可以让你用调试器检查程序的状态。

异常从首个满足异常类型的 `catch` 块继续执行。即使你的代码是正确的，运行时也可能会抛出异常，如 "file not found" 或 "out of memory"。
异常能够处理这些错误，哪怕只是记录日志信息，然后终止程序。

## 引用
https://docs.microsoft.com/en-us/cpp/cpp/errors-and-exception-handling-modern-cpp?view=msvc-160


